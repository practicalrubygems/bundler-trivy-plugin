# frozen_string_literal: true

module Bundler
  module Trivy
    # Represents a single security vulnerability found in a Ruby gem.
    #
    # Vulnerability wraps vulnerability data from Trivy and provides convenient
    # accessors for all vulnerability attributes. It includes helper methods for
    # severity checking, version comparison, and determining if a fix is available.
    #
    # Vulnerabilities are sortable by severity (critical first) and then by package name.
    #
    # @example Basic usage
    #   vuln = Vulnerability.new(trivy_data, "Gemfile.lock")
    #   puts "#{vuln.id}: #{vuln.package_name} (#{vuln.severity})"
    #   puts "Fixed in: #{vuln.fixed_version}" if vuln.fixable?
    #
    # @example Checking severity
    #   if vuln.critical?
    #     puts "CRITICAL: Immediate action required!"
    #   end
    #
    # @example Sorting vulnerabilities
    #   vulns.sort.each { |v| puts v.package_name }
    class Vulnerability
      # Severity ranking for sorting (lower number = higher priority)
      SEVERITY_ORDER = {
        "CRITICAL" => 0,
        "HIGH" => 1,
        "MEDIUM" => 2,
        "LOW" => 3,
        "UNKNOWN" => 4
      }.freeze

      # @return [Hash] Raw vulnerability data from Trivy
      attr_reader :data

      # @return [String] Target file where vulnerability was found (e.g., "Gemfile.lock")
      attr_reader :target

      # Initializes a new Vulnerability instance.
      #
      # @param data [Hash] Raw vulnerability data from Trivy JSON output
      # @param target [String] Target file path where the vulnerability was found
      #
      # @example Create from Trivy data
      #   vuln = Vulnerability.new(data, "Gemfile.lock")
      def initialize(data, target)
        @data = data
        @target = target
      end

      # Returns the CVE or vulnerability identifier.
      #
      # @return [String] CVE ID (e.g., "CVE-2023-12345") or other vulnerability ID
      #
      # @example Get vulnerability ID
      #   vuln.id # => "CVE-2023-12345"
      def id
        @data["VulnerabilityID"]
      end

      # Returns the name of the vulnerable package.
      #
      # @return [String] Package/gem name
      #
      # @example Get package name
      #   vuln.package_name # => "rails"
      def package_name
        @data["PkgName"]
      end

      # Returns the currently installed version of the vulnerable package.
      #
      # @return [String] Installed version number
      def installed_version
        @data["InstalledVersion"]
      end

      # Returns the version(s) that fix this vulnerability.
      #
      # May contain multiple versions separated by commas (e.g., "2.1.4, 3.0.1").
      #
      # @return [String, nil] Fixed version string, or nil if no fix available
      def fixed_version
        @data["FixedVersion"]
      end

      # Returns an array of all available fixed versions.
      #
      # Parses the fixed_version string and splits on commas, extracting
      # version numbers from requirement constraints (e.g., "~> 7.1.5" -> "7.1.5").
      #
      # @return [Array<String>] Array of fixed version strings, empty if no fix available
      #
      # @example Get all fixed versions
      #   vuln.fixed_versions # => ["2.1.4", "3.0.1", "4.0.0"]
      def fixed_versions
        return [] unless fixable?

        fixed_version.split(",").map(&:strip).filter_map do |constraint|
          # Parse as a requirement (e.g., "~> 7.1.5" or ">= 7.1.5.2")
          Gem::Requirement.new(constraint)
          # Extract the version number from the requirement
          # For "~> 7.1.5" -> "7.1.5", ">= 7.1.5.2" -> "7.1.5.2"
          constraint.match(/\d+(?:\.\d+)*/)&.to_s
        rescue ArgumentError
          # If it's not a valid requirement, try to extract version directly
          constraint.match(/\d+(?:\.\d+)*/)&.to_s
        end.compact.reject(&:empty?)
      end

      # Returns the most applicable fixed version for the installed version.
      #
      # Attempts to find a fixed version in the same major.minor series as the
      # installed version. For example, if version 2.1.0 is installed and fixes
      # exist for 2.1.4 and 3.0.1, this returns 2.1.4.
      #
      # @return [String, nil] Most applicable fixed version, or nil if no fix available
      #
      # @example Get applicable fix
      #   # If installed: 2.1.0, fixes: ["2.1.4", "3.0.1"]
      #   vuln.applicable_fixed_version # => "2.1.4"
      def applicable_fixed_version
        return nil unless fixable?

        begin
          installed = Gem::Version.new(installed_version)

          # Find versions in same major.minor series
          same_series = fixed_versions.select do |v|
            fixed = Gem::Version.new(v)
            fixed.segments[0..1] == installed.segments[0..1]
          rescue ArgumentError
            false
          end

          # Return the minimum version in the same series, or the overall minimum
          target_versions = same_series.empty? ? fixed_versions : same_series
          target_versions.min_by do |v|
            Gem::Version.new(v)
          rescue ArgumentError
            # If version parsing fails, use a very high version to sort it last
            Gem::Version.new("999.999.999")
          end
        rescue ArgumentError
          # If version parsing fails, return the first fixed version
          fixed_versions.first
        end
      end

      # Returns the severity level of this vulnerability.
      #
      # @return [String] Severity level: "CRITICAL", "HIGH", "MEDIUM", "LOW", or "UNKNOWN"
      #
      # @example Get severity
      #   vuln.severity # => "CRITICAL"
      def severity
        sev = @data["Severity"]
        return "UNKNOWN" if sev.nil? || sev.empty?

        sev
      end

      # Returns a human-readable title for the vulnerability.
      #
      # @return [String] Vulnerability title or default message
      def title
        @data["Title"] || "No title available"
      end

      # Returns a detailed description of the vulnerability.
      #
      # @return [String] Vulnerability description or default message
      def description
        @data["Description"] || "No description available"
      end

      # Returns the primary URL for more information about the vulnerability.
      #
      # @return [String, nil] URL to vulnerability details (often NVD or GitHub Advisory)
      def primary_url
        @data["PrimaryURL"]
      end

      # Returns additional reference URLs for this vulnerability.
      #
      # @return [Array<String>] Array of reference URLs
      def references
        @data["References"] || []
      end

      # Returns the date this vulnerability was published.
      #
      # @return [String, nil] Publication date in ISO 8601 format
      def published_date
        @data["PublishedDate"]
      end

      # Checks if this is a CRITICAL severity vulnerability.
      #
      # @return [Boolean] true if severity is CRITICAL
      def critical?
        severity == "CRITICAL"
      end

      # Checks if this is a HIGH severity vulnerability.
      #
      # @return [Boolean] true if severity is HIGH
      def high?
        severity == "HIGH"
      end

      # Checks if this is a MEDIUM severity vulnerability.
      #
      # @return [Boolean] true if severity is MEDIUM
      def medium?
        severity == "MEDIUM"
      end

      # Checks if this is a LOW severity vulnerability.
      #
      # @return [Boolean] true if severity is LOW
      def low?
        severity == "LOW"
      end

      # Returns the numeric rank for this severity level.
      #
      # Lower numbers indicate higher severity. Used for sorting.
      #
      # @return [Integer] Severity rank (0-4, or 999 for unknown)
      def severity_rank
        SEVERITY_ORDER[severity] || 999
      end

      # Compares this vulnerability with another for sorting.
      #
      # Vulnerabilities are sorted by severity (critical first), then by package name.
      #
      # @param other [Vulnerability] Another vulnerability to compare with
      # @return [Integer] -1, 0, or 1 for sorting
      #
      # @example Sort vulnerabilities
      #   vulnerabilities.sort # Critical vulnerabilities first
      def <=>(other)
        # Sort by severity first (critical first), then by package name
        comparison = severity_rank <=> other.severity_rank
        comparison.zero? ? package_name <=> other.package_name : comparison
      end

      # Checks if a fix is available for this vulnerability.
      #
      # @return [Boolean] true if a fixed version exists
      #
      # @example Check if fixable
      #   if vuln.fixable?
      #     puts "Update to #{vuln.fixed_version}"
      #   else
      #     puts "No fix available yet"
      #   end
      def fixable?
        !fixed_version.nil? && !fixed_version.empty?
      end
    end
  end
end
