# frozen_string_literal: true

require "test_helper"

module Bundler
  module Trivy
    class VulnerabilityTest < Minitest::Test
      def setup
        super
        @vuln_data = sample_vulnerability
        @vuln = Vulnerability.new(@vuln_data, "Gemfile.lock")
      end

      def test_initialize_sets_data_and_target
        assert_equal @vuln_data, @vuln.data
        assert_equal "Gemfile.lock", @vuln.target
      end

      def test_id_returns_vulnerability_id
        assert_equal "CVE-2023-12345", @vuln.id
      end

      def test_package_name_returns_package
        assert_equal "rack", @vuln.package_name
      end

      def test_installed_version_returns_version
        assert_equal "2.2.3", @vuln.installed_version
      end

      def test_fixed_version_returns_fix
        assert_equal "2.2.8, 2.3.0", @vuln.fixed_version
      end

      def test_fixed_versions_returns_array
        versions = @vuln.fixed_versions
        assert_equal ["2.2.8", "2.3.0"], versions
      end

      def test_fixed_versions_returns_empty_when_no_fix
        vuln_data = sample_vulnerability
        vuln_data["FixedVersion"] = nil
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        assert_equal [], vuln.fixed_versions
      end

      def test_fixed_versions_handles_complex_constraints
        vuln_data = sample_vulnerability
        vuln_data["FixedVersion"] = "~> 2.2.8, >= 3.0.0"
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        versions = vuln.fixed_versions
        assert_equal ["2.2.8", "3.0.0"], versions
      end

      def test_fixed_versions_handles_requirement_constraints
        vuln_data = sample_vulnerability
        vuln_data["FixedVersion"] = ">= 2.2.8"
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        versions = vuln.fixed_versions
        assert_equal ["2.2.8"], versions
      end

      def test_fixed_versions_handles_invalid_constraints
        vuln_data = sample_vulnerability
        vuln_data["FixedVersion"] = "invalid.version, 2.2.8"
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        versions = vuln.fixed_versions
        assert_equal ["2.2.8"], versions
      end

      def test_applicable_fixed_version_finds_matching_series
        # Installed: 2.2.3, fixes: 2.2.8, 2.3.0
        # Should return 2.2.8 (same major.minor)
        assert_equal "2.2.8", @vuln.applicable_fixed_version
      end

      def test_applicable_fixed_version_returns_nil_when_no_fix
        vuln_data = sample_vulnerability
        vuln_data["FixedVersion"] = nil
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        assert_nil vuln.applicable_fixed_version
      end

      def test_applicable_fixed_version_returns_first_on_parse_error
        vuln_data = sample_vulnerability
        vuln_data["InstalledVersion"] = "invalid.version"
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        # Should fall back to first version
        assert_equal "2.2.8", vuln.applicable_fixed_version
      end

      def test_applicable_fixed_version_handles_invalid_fixed_versions
        vuln_data = sample_vulnerability
        vuln_data["FixedVersion"] = "2.2.8, invalid.version, 2.3.0"
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        # Should skip invalid versions and return valid one
        assert_equal "2.2.8", vuln.applicable_fixed_version
      end

      def test_applicable_fixed_version_returns_overall_min_when_no_same_series
        vuln_data = sample_vulnerability
        vuln_data["InstalledVersion"] = "1.0.0"
        vuln_data["FixedVersion"] = "2.0.0, 3.0.0"
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        # Installed is 1.0.0, fixes are 2.0.0 and 3.0.0 (different series)
        # Should return the minimum overall: 2.0.0
        assert_equal "2.0.0", vuln.applicable_fixed_version
      end

      def test_applicable_fixed_version_handles_all_invalid_fixed_versions
        vuln_data = sample_vulnerability
        vuln_data["FixedVersion"] = "invalid, not-a-version"
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        # Should return nil when all fixed versions are invalid
        assert_nil vuln.applicable_fixed_version
      end

      def test_severity_returns_level
        assert_equal "CRITICAL", @vuln.severity
      end

      def test_severity_returns_unknown_for_nil
        vuln_data = sample_vulnerability
        vuln_data["Severity"] = nil
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        assert_equal "UNKNOWN", vuln.severity
      end

      def test_severity_returns_unknown_for_empty
        vuln_data = sample_vulnerability
        vuln_data["Severity"] = ""
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        assert_equal "UNKNOWN", vuln.severity
      end

      def test_title_returns_title
        assert_equal "rack vulnerability", @vuln.title
      end

      def test_title_returns_default_when_missing
        vuln_data = sample_vulnerability
        vuln_data.delete("Title")
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        assert_equal "No title available", vuln.title
      end

      def test_description_returns_description
        assert_equal "Sample vulnerability description", @vuln.description
      end

      def test_description_returns_default_when_missing
        vuln_data = sample_vulnerability
        vuln_data.delete("Description")
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        assert_equal "No description available", vuln.description
      end

      def test_primary_url_returns_url
        assert_equal "https://avd.aquasec.com/nvd/cve-2023-12345", @vuln.primary_url
      end

      def test_references_returns_array
        assert_equal [], @vuln.references
      end

      def test_published_date_returns_date
        assert_nil @vuln.published_date
      end

      def test_critical_predicate
        assert @vuln.critical?
        refute Vulnerability.new(sample_vulnerability(severity: "HIGH"), "Gemfile.lock").critical?
      end

      def test_high_predicate
        refute @vuln.high?
        assert Vulnerability.new(sample_vulnerability(severity: "HIGH"), "Gemfile.lock").high?
      end

      def test_medium_predicate
        refute @vuln.medium?
        assert Vulnerability.new(sample_vulnerability(severity: "MEDIUM"), "Gemfile.lock").medium?
      end

      def test_low_predicate
        refute @vuln.low?
        assert Vulnerability.new(sample_vulnerability(severity: "LOW"), "Gemfile.lock").low?
      end

      def test_severity_rank_returns_correct_order
        critical = Vulnerability.new(sample_vulnerability(severity: "CRITICAL"), "Gemfile.lock")
        high = Vulnerability.new(sample_vulnerability(severity: "HIGH"), "Gemfile.lock")
        medium = Vulnerability.new(sample_vulnerability(severity: "MEDIUM"), "Gemfile.lock")
        low = Vulnerability.new(sample_vulnerability(severity: "LOW"), "Gemfile.lock")
        unknown = Vulnerability.new(sample_vulnerability(severity: "UNKNOWN"), "Gemfile.lock")

        assert_equal 0, critical.severity_rank
        assert_equal 1, high.severity_rank
        assert_equal 2, medium.severity_rank
        assert_equal 3, low.severity_rank
        assert_equal 4, unknown.severity_rank
      end

      def test_severity_rank_returns_999_for_invalid
        vuln_data = sample_vulnerability
        vuln_data["Severity"] = "INVALID"
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        assert_equal 999, vuln.severity_rank
      end

      def test_spaceship_operator_sorts_by_severity
        critical = Vulnerability.new(sample_vulnerability(severity: "CRITICAL", pkg_name: "rack"), "Gemfile.lock")
        high = Vulnerability.new(sample_vulnerability(severity: "HIGH", pkg_name: "rails"), "Gemfile.lock")

        # Critical should come before high
        assert_equal(-1, critical <=> high)
        assert_equal 1, high <=> critical
      end

      def test_spaceship_operator_sorts_by_package_name_when_same_severity
        rack = Vulnerability.new(sample_vulnerability(severity: "CRITICAL", pkg_name: "rack"), "Gemfile.lock")
        rails = Vulnerability.new(sample_vulnerability(severity: "CRITICAL", pkg_name: "rails"), "Gemfile.lock")

        # Rack should come before rails alphabetically
        assert_equal(-1, rack <=> rails)
        assert_equal 1, rails <=> rack
      end

      def test_sorting_vulnerabilities
        vulns = [
          Vulnerability.new(sample_vulnerability(severity: "LOW", pkg_name: "zlib"), "Gemfile.lock"),
          Vulnerability.new(sample_vulnerability(severity: "CRITICAL", pkg_name: "rails"), "Gemfile.lock"),
          Vulnerability.new(sample_vulnerability(severity: "HIGH", pkg_name: "rack"), "Gemfile.lock"),
          Vulnerability.new(sample_vulnerability(severity: "CRITICAL", pkg_name: "activerecord"), "Gemfile.lock")
        ]

        sorted = vulns.sort

        # Should be sorted: CRITICAL(activerecord), CRITICAL(rails), HIGH(rack), LOW(zlib)
        assert_equal "activerecord", sorted[0].package_name
        assert_equal "rails", sorted[1].package_name
        assert_equal "rack", sorted[2].package_name
        assert_equal "zlib", sorted[3].package_name
      end

      def test_fixable_returns_true_when_fix_available
        assert @vuln.fixable?
      end

      def test_fixable_returns_false_when_no_fix
        vuln_data = sample_vulnerability
        vuln_data["FixedVersion"] = nil
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        refute vuln.fixable?
      end

      def test_fixable_returns_false_when_fix_empty
        vuln_data = sample_vulnerability
        vuln_data["FixedVersion"] = ""
        vuln = Vulnerability.new(vuln_data, "Gemfile.lock")

        refute vuln.fixable?
      end
    end
  end
end
